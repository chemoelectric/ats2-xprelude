divert(-1)

Copyright Â© 2022, 2023 Barry Schwartz

This program is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License, as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received copies of the GNU General Public License
along with this program. If not, see
<https://www.gnu.org/licenses/>.

/*------------------------------------------------------------------*/

m4_define(`my_extern_prefix',`ats2_xprelude_')
m4_define(`MY_EXTERN_PREFIX',`m4_toupper(my_extern_prefix)')

/*------------------------------------------------------------------*/
/* Comparisons. */

m4_define(`comparisons',`lt,lte,gt,gte,eq,neq')

m4_define(`ats_cmp_dynamic',
  `m4_if($1,`lt',`<',
         $1,`lte',`<=',
         $1,`gt',`>',
         $1,`gte',`>=',
         $1,`eq',`=',
         $1,`neq',`<>')')

m4_define(`ats_cmp_static',
  `m4_if($1,`lt',`<',
         $1,`lte',`<=',
         $1,`gt',`>',
         $1,`gte',`>=',
         $1,`eq',`==',
         $1,`neq',`!=')')

m4_define(`ats_cmp_c',
  `m4_if($1,`lt',`<',
         $1,`lte',`<=',
         $1,`gt',`>',
         $1,`gte',`>=',
         $1,`eq',`==',
         $1,`neq',`!=')')

/*------------------------------------------------------------------*/
/* Unary and binary operations. */

m4_define(`ats_binop_c',
  `m4_if($1,`add',`+',
         $1,`sub',`-',
         $1,`mul',`*',
         $1,`div',`/',
         $1,`mod',`%',
         $1,`land',`&',
         $1,`lor',`|',
         $1,`lxor',`^')')

/*------------------------------------------------------------------*/
/* Integer kinds. */

m4_define(`conventional_intbases',
  `sint,int,lint,llint,int8,int16,int32,int64,ssize,intptr,intmax')

m4_define(`conventional_uintbases',
  `m4_shift(m4_foreachq(`X',`conventional_intbases',
                        `,int2uintbase(X)'))')

m4_define(`intbases',`conventional_intbases')
m4_define(`uintbases',
  `m4_shift(m4_foreachq(`X',`intbases',`,int2uintbase(X)'))')

m4_define(`int2uintbase',`m4_if($1,`ssize',`size',`u$1')')
m4_define(`intb2k',`$1knd')
m4_define(`uintb2k',`$1knd')
m4_define(`intb2t',`m4_if($1,`ssize',`ssize_t',`$1')')
m4_define(`uintb2t',`m4_if($1,`size',`size_t',`$1')')
m4_define(`intt2b',`m4_if($1,`ssize_t',`ssize',`$1')')
m4_define(`uintt2b',`m4_if($1,`size_t',`size',`$1')')
m4_define(`intb2c',`m4_if($1,`intmax',`ats2_xprelude_intmax',
                          `atstype_$1')')
m4_define(`uintb2c',`m4_if($1,`uintmax',`ats2_xprelude_uintmax',
                           `atstype_$1')')

m4_define(`intkinds',
  `m4_shift(m4_foreachq(`X',`intbases',`,intb2k(X)'))')
m4_define(`uintkinds',
  `m4_shift(m4_foreachq(`X',`uintbases',`,uintb2k(X)'))')

m4_define(`inttypes',
  `m4_shift(m4_foreachq(`X',`intbases',`,intb2t(X)'))')
m4_define(`uinttypes',
  `m4_shift(m4_foreachq(`X',`uintbases',`,uintb2t(X)'))')

m4_define(`intt2k',`intb2k(intt2b($1))')
m4_define(`uintt2k',`uintb2k(uintt2b($1))')

/* A string beginning "tk" is presumed to be a typekind already. */
m4_define(`int_tk',
  `m4_if(m4_substr(`$1',0,2),`tk',`$1',`intb2k(`$1')')')
m4_define(`uint_tk',
  `m4_if(m4_substr(`$1',0,2),`tk',`$1',`uintb2k(`$1')')')

m4_define(`m4_g0int',`g0int int_tk($1)')
m4_define(`m4_g0uint',`g0uint uint_tk($1)')
m4_define(`m4_g1int',`g1int (int_tk($1), $2)')
m4_define(`m4_g1uint',`g1uint (uint_tk($1), $2)')

m4_define(`m4_g0int_comparison',`(m4_g0int($1), m4_g0int($1)) -<> bool')
m4_define(`m4_g0uint_comparison',`(m4_g0uint($1), m4_g0uint($1)) -<> bool')
m4_define(`m4_g1int_comparison',`(m4_g1int($1, $2), m4_g1int($1, $3)) -<> bool ($4)')
m4_define(`m4_g1uint_comparison',`(m4_g1uint($1, $2), m4_g1uint($1, $3)) -<> bool ($4)')

m4_define(`m4_g0int_compare0',`m4_g0int($1) -<> bool')
m4_define(`m4_g0uint_compare0',`m4_g0uint($1) -<> bool')
m4_define(`m4_g1int_compare0',`m4_g1int($1, $2) -<> bool ($3)')
m4_define(`m4_g1uint_compare0',`m4_g1uint($1, $2) -<> bool ($3)')

m4_define(`m4_g0int_unary',`m4_g0int($1) -<> m4_g0int($1)')
m4_define(`m4_g0uint_unary',`m4_g0uint($1) -<> m4_g0uint($1)')
m4_define(`m4_g1int_unary',`m4_g1int($1, $2) -<> m4_g1int($1, $3)')
m4_define(`m4_g1uint_unary',`m4_g1uint($1, $2) -<> m4_g1uint($1, $3)')

m4_define(`m4_g0int_binary',`(m4_g0int($1), m4_g0int($1)) -<> m4_g0int($1)')
m4_define(`m4_g0uint_binary',`(m4_g0uint($1), m4_g0uint($1)) -<> m4_g0uint($1)')
m4_define(`m4_g1int_binary',`(m4_g1int($1, $2), m4_g1int($1, $3)) -<> m4_g1int($1, $4)')
m4_define(`m4_g1uint_binary',`(m4_g1uint($1, $2), m4_g1uint($1, $3)) -<> m4_g1uint($1, $4)')

m4_define(`m4_g0uint_logical_shift',`(m4_g0uint($1), intGte 0) -<> m4_g0uint($1)')
m4_define(`m4_g1uint_logical_shift',`(m4_g1uint($1, $2), int $3) -<> m4_g1uint($1, $4)')

m4_define(`m4_g0int_arith_shift',`(m4_g0int($1), intGte 0) -<> m4_g0int($1)')
m4_define(`m4_g1int_arith_shift',`(m4_g1int($1, $2), int $3) -<> m4_g1int($1, $4)')

/*------------------------------------------------------------------*/
/* Floating point kinds. */

m4_define(`conventional_floattypes',`float,double,ldouble')
m4_define(`floattypes',`conventional_floattypes,fixed32p32,exrat')

m4_define(`floatt2k',`$1`'_kind')

m4_define(`floatt2c',
`m4_if($1,`fixed32p32',`ats2_xprelude_fixed32p32',
       $1,`exrat',`ats2_xprelude_exrat',
       `atstype_$1')')

m4_define(`floatt2sfx',
`m4_if($1,`float',`f',
       $1,`double',`',
       $1,`ldouble',`l',
       $1,`float16',`f16',
       $1,`float16x',`f16x',
       $1,`float32',`f32',
       $1,`float32x',`f32x',
       $1,`float64',`f64',
       $1,`float64x',`f64x',
       $1,`float128',`f128',
       $1,`float128x',`f128x')')

m4_define(`floatt2SFX',
`m4_if($1,`float',`F',
       $1,`double',`',
       $1,`ldouble',`L',
       $1,`float16',`F16',
       $1,`float16x',`F16X',
       $1,`float32',`F32',
       $1,`float32x',`F32X',
       $1,`float64',`F64',
       $1,`float64x',`F64X',
       $1,`float128',`F128',
       $1,`float128x',`F128X')')

m4_define(`floatt2PFX',
`m4_if($1,`float',`FLT',
       $1,`double',`DBL',
       $1,`ldouble',`LDBL',
       $1,`float16',`F16',
       $1,`float16x',`F16X',
       $1,`float32',`F32',
       $1,`float32x',`F32X',
       $1,`float64',`F64',
       $1,`float64x',`F64X',
       $1,`float128',`F128',
       $1,`float128x',`F128X')')

/* A string beginning "tk" is presumed to be a typekind already. */
m4_define(`float_tk',
  `m4_if(m4_substr(`$1',0,2),`tk',`$1',`floatt2k(`$1')')')

m4_define(`m4_g0float',`g0float float_tk($1)')

/* How we tell if a floating point type is supported. */
m4_define(`FLOAT_SUPPORT_CHECK',
    ``#'if defined floatt2PFX(`$1')_MANT_DIG && 0 < floatt2PFX(`$1')_MANT_DIG')
m4_define(`END_FLOAT_SUPPORT_CHECK',``#'endif')

/*------------------------------------------------------------------*/
/* Floating point operations. */

m4_define(`floatt2op',`$2`'floatt2sfx(`$1')')

m4_define(`trunc_ops',`round,nearbyint,rint,floor,ceil,trunc')

m4_define(`radical_ops',`sqrt,cbrt')
m4_define(`pow_ops',`pow')
m4_define(`exp_ops',`exp,exp2')
m4_define(`log_ops',`log,log2,log10')

m4_define(`sign_ops',`fabs')

m4_define(`trig_ops',`sin,cos,tan,asin,acos,atan')
m4_define(`trig2_ops',`atan2')

m4_define(`unary_ops',`trunc_ops,
                       radical_ops,exp_ops,log_ops,
                       sign_ops,trig_ops')
m4_define(`binary_ops',`pow_ops,trig2_ops')
m4_define(`trinary_ops',`fma')

/*------------------------------------------------------------------*/

divert`'dnl
