Extensions to, and bugfixes for, the ATS2 prelude.
--------------------------------------------------

THIS PROJECT IS A WORK IN PROGRESS.

* Expanded support for integer types, and workarounds for
  bugs. Changes include at least the following:

    - I have added intmax and uintmax.

    - I have worked around bugs in g1 versions of comparisons with
      zero.

    - I have tightened the postconditions of g1 versions of mod and
      nmod.

    - I have added ‘true Euclidean division’ of signed integers,
      where the remainder is always non-negative.

* Expanded support for floating point, and workarounds for bugs.

* 32+32-bit fixed point, treated as if it were floating point
  (g0float).

* Optionally: exact rationals (via the GNU Multiple Precision
  Arithmetic Library). These are a nonlinear type (for garbage
  collection), and are treated as if they were floating point
  (g0float).

* Planned but not yet added: sorting by default algorithms that you do
  not have to think about. (For array sorting, the preferred
  implementation will be ats2-timsort. I suppose ats2-quicksorts may
  also be made available as choices. And the prelude’s own sort
  implementations.)

* Also possible: C complex types, treated in ATS as floating point
  types.

* Also possible: moving my ‘bisection iterators’ here. They use the
  exact rationals and can be used to do adaptive algorithms without
  non-tail recursion.

* Also possible: gcd and lcm operations.

* Also possible: ‘lldouble’ as a type that could be larger than
  ldouble. In particular, on AMD64, this could be _Float128, which GCC
  supports on that platform (although via a library rather than
  hardware). ¶ Note: Some seem to believe that, with GCC on AMD64,
  ldouble is a 128-bit floating point type. It is not; it is an 80-bit
  type that goes back to the 8087. The 80 bits *are* stored in 128
  bits of space, but that is for alignment, and such alignment is
  required by the AMD64 ABI. ¶ By the way, on 32-bit x86, ‘ldouble’
  similarly is more efficiently accessed when it is aligned on 128-bit
  boundaries. However, the ABI for x86 was designed for older
  processors, such as 80386, and specifies 96-bit boundaries.

* Also possible: 128-bit integers, using compiler support if possible,
  otherwise by library code.
