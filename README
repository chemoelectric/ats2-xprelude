Extensions to, and bugfixes for, the ATS2 prelude.
--------------------------------------------------

THIS PROJECT IS A WORK IN PROGRESS.

* Expanded support for integer types, and workarounds for
  bugs. Changes include at least the following:

    - I have added intmax and uintmax.

    - I have worked around bugs in g1 versions of comparisons with
      zero.

    - I have tightened the postconditions of g1 versions of mod and
      nmod.

    - I have added ‘true Euclidean division’ of signed integers,
      where the remainder is always non-negative.

* Expanded support for floating point, and workarounds for bugs.

* Support for the following floating point types: float16, float32,
  float64, float128, float16x float32x, float64x, float128x,
  decimal32, decimal64, decimal128, decimal64x, decimal128x. Your C
  compiler and libraries are likely to support some of these but not
  others, in varying degrees. ¶ Footnote: On AMD64, the ldouble type
  is stored on 128-bit boundaries, but it is NOT a 128-bit floating
  point type. It is an 80-bit floating point type, which is stored on
  32-bit boundaries on x86. If you want quad precision on AMD64, use
  float128 (which requires libraries that come with GCC).

* 32+32-bit fixed point, treated as if it were floating point
  (g0float).

* Optionally: exact rationals (via the GNU Multiple Precision
  Arithmetic Library). These are a nonlinear type (for garbage
  collection), and are treated as if they were floating point
  (g0float).

* Sorting, with algorithms selectable via -DATS flag.

---

* Also possible: C complex types, treated in ATS as floating point
  types.

* Also possible: moving my ‘bisection iterators’ here. They use the
  exact rationals and can be used to do adaptive algorithms without
  non-tail recursion.

* Also possible: gcd and lcm operations.

* Also possible: 128-bit integers, using compiler support if possible,
  otherwise by library code.

